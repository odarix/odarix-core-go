// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package delivery_test

import (
	"context"
	"github.com/google/uuid"
	"github.com/odarix/odarix-core-go/cppbridge"
	"github.com/odarix/odarix-core-go/delivery"
	"github.com/odarix/odarix-core-go/frames"
	"io"
	"sync"
)

// Ensure, that DialerMock does implement delivery.Dialer.
// If this is not the case, regenerate this file with moq.
var _ delivery.Dialer = &DialerMock{}

// DialerMock is a mock implementation of delivery.Dialer.
//
//	func TestSomethingThatUsesDialer(t *testing.T) {
//
//		// make and configure a mocked delivery.Dialer
//		mockedDialer := &DialerMock{
//			DialFunc: func(ctx context.Context, shardMeta delivery.ShardMeta) (delivery.Transport, error) {
//				panic("mock out the Dial method")
//			},
//			SendRefillFunc: func(ctx context.Context, r io.Reader, shardMeta delivery.ShardMeta) error {
//				panic("mock out the SendRefill method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//		}
//
//		// use mockedDialer in code that requires delivery.Dialer
//		// and then make assertions.
//
//	}
type DialerMock struct {
	// DialFunc mocks the Dial method.
	DialFunc func(ctx context.Context, shardMeta delivery.ShardMeta) (delivery.Transport, error)

	// SendRefillFunc mocks the SendRefill method.
	SendRefillFunc func(ctx context.Context, r io.Reader, shardMeta delivery.ShardMeta) error

	// StringFunc mocks the String method.
	StringFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Dial holds details about calls to the Dial method.
		Dial []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ShardMeta is the shardMeta argument value.
			ShardMeta delivery.ShardMeta
		}
		// SendRefill holds details about calls to the SendRefill method.
		SendRefill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// R is the r argument value.
			R io.Reader
			// ShardMeta is the shardMeta argument value.
			ShardMeta delivery.ShardMeta
		}
		// String holds details about calls to the String method.
		String []struct {
		}
	}
	lockDial       sync.RWMutex
	lockSendRefill sync.RWMutex
	lockString     sync.RWMutex
}

// Dial calls DialFunc.
func (mock *DialerMock) Dial(ctx context.Context, shardMeta delivery.ShardMeta) (delivery.Transport, error) {
	if mock.DialFunc == nil {
		panic("DialerMock.DialFunc: method is nil but Dialer.Dial was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ShardMeta delivery.ShardMeta
	}{
		Ctx:       ctx,
		ShardMeta: shardMeta,
	}
	mock.lockDial.Lock()
	mock.calls.Dial = append(mock.calls.Dial, callInfo)
	mock.lockDial.Unlock()
	return mock.DialFunc(ctx, shardMeta)
}

// DialCalls gets all the calls that were made to Dial.
// Check the length with:
//
//	len(mockedDialer.DialCalls())
func (mock *DialerMock) DialCalls() []struct {
	Ctx       context.Context
	ShardMeta delivery.ShardMeta
} {
	var calls []struct {
		Ctx       context.Context
		ShardMeta delivery.ShardMeta
	}
	mock.lockDial.RLock()
	calls = mock.calls.Dial
	mock.lockDial.RUnlock()
	return calls
}

// SendRefill calls SendRefillFunc.
func (mock *DialerMock) SendRefill(ctx context.Context, r io.Reader, shardMeta delivery.ShardMeta) error {
	if mock.SendRefillFunc == nil {
		panic("DialerMock.SendRefillFunc: method is nil but Dialer.SendRefill was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		R         io.Reader
		ShardMeta delivery.ShardMeta
	}{
		Ctx:       ctx,
		R:         r,
		ShardMeta: shardMeta,
	}
	mock.lockSendRefill.Lock()
	mock.calls.SendRefill = append(mock.calls.SendRefill, callInfo)
	mock.lockSendRefill.Unlock()
	return mock.SendRefillFunc(ctx, r, shardMeta)
}

// SendRefillCalls gets all the calls that were made to SendRefill.
// Check the length with:
//
//	len(mockedDialer.SendRefillCalls())
func (mock *DialerMock) SendRefillCalls() []struct {
	Ctx       context.Context
	R         io.Reader
	ShardMeta delivery.ShardMeta
} {
	var calls []struct {
		Ctx       context.Context
		R         io.Reader
		ShardMeta delivery.ShardMeta
	}
	mock.lockSendRefill.RLock()
	calls = mock.calls.SendRefill
	mock.lockSendRefill.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *DialerMock) String() string {
	if mock.StringFunc == nil {
		panic("DialerMock.StringFunc: method is nil but Dialer.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedDialer.StringCalls())
func (mock *DialerMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// Ensure, that TransportMock does implement delivery.Transport.
// If this is not the case, regenerate this file with moq.
var _ delivery.Transport = &TransportMock{}

// TransportMock is a mock implementation of delivery.Transport.
//
//	func TestSomethingThatUsesTransport(t *testing.T) {
//
//		// make and configure a mocked delivery.Transport
//		mockedTransport := &TransportMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			ListenFunc: func(ctx context.Context)  {
//				panic("mock out the Listen method")
//			},
//			OnAckFunc: func(fn func(uint32))  {
//				panic("mock out the OnAck method")
//			},
//			OnReadErrorFunc: func(fn func(err error))  {
//				panic("mock out the OnReadError method")
//			},
//			OnRejectFunc: func(fn func(uint32))  {
//				panic("mock out the OnReject method")
//			},
//			SendFunc: func(contextMoqParam context.Context, frameWriter frames.FrameWriter) error {
//				panic("mock out the Send method")
//			},
//		}
//
//		// use mockedTransport in code that requires delivery.Transport
//		// and then make assertions.
//
//	}
type TransportMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ListenFunc mocks the Listen method.
	ListenFunc func(ctx context.Context)

	// OnAckFunc mocks the OnAck method.
	OnAckFunc func(fn func(uint32))

	// OnReadErrorFunc mocks the OnReadError method.
	OnReadErrorFunc func(fn func(err error))

	// OnRejectFunc mocks the OnReject method.
	OnRejectFunc func(fn func(uint32))

	// SendFunc mocks the Send method.
	SendFunc func(contextMoqParam context.Context, frameWriter frames.FrameWriter) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Listen holds details about calls to the Listen method.
		Listen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// OnAck holds details about calls to the OnAck method.
		OnAck []struct {
			// Fn is the fn argument value.
			Fn func(uint32)
		}
		// OnReadError holds details about calls to the OnReadError method.
		OnReadError []struct {
			// Fn is the fn argument value.
			Fn func(err error)
		}
		// OnReject holds details about calls to the OnReject method.
		OnReject []struct {
			// Fn is the fn argument value.
			Fn func(uint32)
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// FrameWriter is the frameWriter argument value.
			FrameWriter frames.FrameWriter
		}
	}
	lockClose       sync.RWMutex
	lockListen      sync.RWMutex
	lockOnAck       sync.RWMutex
	lockOnReadError sync.RWMutex
	lockOnReject    sync.RWMutex
	lockSend        sync.RWMutex
}

// Close calls CloseFunc.
func (mock *TransportMock) Close() error {
	if mock.CloseFunc == nil {
		panic("TransportMock.CloseFunc: method is nil but Transport.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedTransport.CloseCalls())
func (mock *TransportMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Listen calls ListenFunc.
func (mock *TransportMock) Listen(ctx context.Context) {
	if mock.ListenFunc == nil {
		panic("TransportMock.ListenFunc: method is nil but Transport.Listen was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListen.Lock()
	mock.calls.Listen = append(mock.calls.Listen, callInfo)
	mock.lockListen.Unlock()
	mock.ListenFunc(ctx)
}

// ListenCalls gets all the calls that were made to Listen.
// Check the length with:
//
//	len(mockedTransport.ListenCalls())
func (mock *TransportMock) ListenCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListen.RLock()
	calls = mock.calls.Listen
	mock.lockListen.RUnlock()
	return calls
}

// OnAck calls OnAckFunc.
func (mock *TransportMock) OnAck(fn func(uint32)) {
	if mock.OnAckFunc == nil {
		panic("TransportMock.OnAckFunc: method is nil but Transport.OnAck was just called")
	}
	callInfo := struct {
		Fn func(uint32)
	}{
		Fn: fn,
	}
	mock.lockOnAck.Lock()
	mock.calls.OnAck = append(mock.calls.OnAck, callInfo)
	mock.lockOnAck.Unlock()
	mock.OnAckFunc(fn)
}

// OnAckCalls gets all the calls that were made to OnAck.
// Check the length with:
//
//	len(mockedTransport.OnAckCalls())
func (mock *TransportMock) OnAckCalls() []struct {
	Fn func(uint32)
} {
	var calls []struct {
		Fn func(uint32)
	}
	mock.lockOnAck.RLock()
	calls = mock.calls.OnAck
	mock.lockOnAck.RUnlock()
	return calls
}

// OnReadError calls OnReadErrorFunc.
func (mock *TransportMock) OnReadError(fn func(err error)) {
	if mock.OnReadErrorFunc == nil {
		panic("TransportMock.OnReadErrorFunc: method is nil but Transport.OnReadError was just called")
	}
	callInfo := struct {
		Fn func(err error)
	}{
		Fn: fn,
	}
	mock.lockOnReadError.Lock()
	mock.calls.OnReadError = append(mock.calls.OnReadError, callInfo)
	mock.lockOnReadError.Unlock()
	mock.OnReadErrorFunc(fn)
}

// OnReadErrorCalls gets all the calls that were made to OnReadError.
// Check the length with:
//
//	len(mockedTransport.OnReadErrorCalls())
func (mock *TransportMock) OnReadErrorCalls() []struct {
	Fn func(err error)
} {
	var calls []struct {
		Fn func(err error)
	}
	mock.lockOnReadError.RLock()
	calls = mock.calls.OnReadError
	mock.lockOnReadError.RUnlock()
	return calls
}

// OnReject calls OnRejectFunc.
func (mock *TransportMock) OnReject(fn func(uint32)) {
	if mock.OnRejectFunc == nil {
		panic("TransportMock.OnRejectFunc: method is nil but Transport.OnReject was just called")
	}
	callInfo := struct {
		Fn func(uint32)
	}{
		Fn: fn,
	}
	mock.lockOnReject.Lock()
	mock.calls.OnReject = append(mock.calls.OnReject, callInfo)
	mock.lockOnReject.Unlock()
	mock.OnRejectFunc(fn)
}

// OnRejectCalls gets all the calls that were made to OnReject.
// Check the length with:
//
//	len(mockedTransport.OnRejectCalls())
func (mock *TransportMock) OnRejectCalls() []struct {
	Fn func(uint32)
} {
	var calls []struct {
		Fn func(uint32)
	}
	mock.lockOnReject.RLock()
	calls = mock.calls.OnReject
	mock.lockOnReject.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *TransportMock) Send(contextMoqParam context.Context, frameWriter frames.FrameWriter) error {
	if mock.SendFunc == nil {
		panic("TransportMock.SendFunc: method is nil but Transport.Send was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		FrameWriter     frames.FrameWriter
	}{
		ContextMoqParam: contextMoqParam,
		FrameWriter:     frameWriter,
	}
	mock.lockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	mock.lockSend.Unlock()
	return mock.SendFunc(contextMoqParam, frameWriter)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//
//	len(mockedTransport.SendCalls())
func (mock *TransportMock) SendCalls() []struct {
	ContextMoqParam context.Context
	FrameWriter     frames.FrameWriter
} {
	var calls []struct {
		ContextMoqParam context.Context
		FrameWriter     frames.FrameWriter
	}
	mock.lockSend.RLock()
	calls = mock.calls.Send
	mock.lockSend.RUnlock()
	return calls
}

// Ensure, that ManagerEncoderMock does implement delivery.ManagerEncoder.
// If this is not the case, regenerate this file with moq.
var _ delivery.ManagerEncoder = &ManagerEncoderMock{}

// ManagerEncoderMock is a mock implementation of delivery.ManagerEncoder.
//
//	func TestSomethingThatUsesManagerEncoder(t *testing.T) {
//
//		// make and configure a mocked delivery.ManagerEncoder
//		mockedManagerEncoder := &ManagerEncoderMock{
//			AddFunc: func(contextMoqParam context.Context, shardedData cppbridge.ShardedData) (cppbridge.SegmentStats, error) {
//				panic("mock out the Add method")
//			},
//			EncodeFunc: func(contextMoqParam context.Context, shardedData cppbridge.ShardedData) (cppbridge.SegmentKey, cppbridge.Segment, error) {
//				panic("mock out the Encode method")
//			},
//			FinalizeFunc: func(contextMoqParam context.Context) (cppbridge.SegmentKey, cppbridge.Segment, error) {
//				panic("mock out the Finalize method")
//			},
//			LastEncodedSegmentFunc: func() uint32 {
//				panic("mock out the LastEncodedSegment method")
//			},
//		}
//
//		// use mockedManagerEncoder in code that requires delivery.ManagerEncoder
//		// and then make assertions.
//
//	}
type ManagerEncoderMock struct {
	// AddFunc mocks the Add method.
	AddFunc func(contextMoqParam context.Context, shardedData cppbridge.ShardedData) (cppbridge.SegmentStats, error)

	// EncodeFunc mocks the Encode method.
	EncodeFunc func(contextMoqParam context.Context, shardedData cppbridge.ShardedData) (cppbridge.SegmentKey, cppbridge.Segment, error)

	// FinalizeFunc mocks the Finalize method.
	FinalizeFunc func(contextMoqParam context.Context) (cppbridge.SegmentKey, cppbridge.Segment, error)

	// LastEncodedSegmentFunc mocks the LastEncodedSegment method.
	LastEncodedSegmentFunc func() uint32

	// calls tracks calls to the methods.
	calls struct {
		// Add holds details about calls to the Add method.
		Add []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// ShardedData is the shardedData argument value.
			ShardedData cppbridge.ShardedData
		}
		// Encode holds details about calls to the Encode method.
		Encode []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// ShardedData is the shardedData argument value.
			ShardedData cppbridge.ShardedData
		}
		// Finalize holds details about calls to the Finalize method.
		Finalize []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// LastEncodedSegment holds details about calls to the LastEncodedSegment method.
		LastEncodedSegment []struct {
		}
	}
	lockAdd                sync.RWMutex
	lockEncode             sync.RWMutex
	lockFinalize           sync.RWMutex
	lockLastEncodedSegment sync.RWMutex
}

// Add calls AddFunc.
func (mock *ManagerEncoderMock) Add(contextMoqParam context.Context, shardedData cppbridge.ShardedData) (cppbridge.SegmentStats, error) {
	if mock.AddFunc == nil {
		panic("ManagerEncoderMock.AddFunc: method is nil but ManagerEncoder.Add was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		ShardedData     cppbridge.ShardedData
	}{
		ContextMoqParam: contextMoqParam,
		ShardedData:     shardedData,
	}
	mock.lockAdd.Lock()
	mock.calls.Add = append(mock.calls.Add, callInfo)
	mock.lockAdd.Unlock()
	return mock.AddFunc(contextMoqParam, shardedData)
}

// AddCalls gets all the calls that were made to Add.
// Check the length with:
//
//	len(mockedManagerEncoder.AddCalls())
func (mock *ManagerEncoderMock) AddCalls() []struct {
	ContextMoqParam context.Context
	ShardedData     cppbridge.ShardedData
} {
	var calls []struct {
		ContextMoqParam context.Context
		ShardedData     cppbridge.ShardedData
	}
	mock.lockAdd.RLock()
	calls = mock.calls.Add
	mock.lockAdd.RUnlock()
	return calls
}

// Encode calls EncodeFunc.
func (mock *ManagerEncoderMock) Encode(contextMoqParam context.Context, shardedData cppbridge.ShardedData) (cppbridge.SegmentKey, cppbridge.Segment, error) {
	if mock.EncodeFunc == nil {
		panic("ManagerEncoderMock.EncodeFunc: method is nil but ManagerEncoder.Encode was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		ShardedData     cppbridge.ShardedData
	}{
		ContextMoqParam: contextMoqParam,
		ShardedData:     shardedData,
	}
	mock.lockEncode.Lock()
	mock.calls.Encode = append(mock.calls.Encode, callInfo)
	mock.lockEncode.Unlock()
	return mock.EncodeFunc(contextMoqParam, shardedData)
}

// EncodeCalls gets all the calls that were made to Encode.
// Check the length with:
//
//	len(mockedManagerEncoder.EncodeCalls())
func (mock *ManagerEncoderMock) EncodeCalls() []struct {
	ContextMoqParam context.Context
	ShardedData     cppbridge.ShardedData
} {
	var calls []struct {
		ContextMoqParam context.Context
		ShardedData     cppbridge.ShardedData
	}
	mock.lockEncode.RLock()
	calls = mock.calls.Encode
	mock.lockEncode.RUnlock()
	return calls
}

// Finalize calls FinalizeFunc.
func (mock *ManagerEncoderMock) Finalize(contextMoqParam context.Context) (cppbridge.SegmentKey, cppbridge.Segment, error) {
	if mock.FinalizeFunc == nil {
		panic("ManagerEncoderMock.FinalizeFunc: method is nil but ManagerEncoder.Finalize was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockFinalize.Lock()
	mock.calls.Finalize = append(mock.calls.Finalize, callInfo)
	mock.lockFinalize.Unlock()
	return mock.FinalizeFunc(contextMoqParam)
}

// FinalizeCalls gets all the calls that were made to Finalize.
// Check the length with:
//
//	len(mockedManagerEncoder.FinalizeCalls())
func (mock *ManagerEncoderMock) FinalizeCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockFinalize.RLock()
	calls = mock.calls.Finalize
	mock.lockFinalize.RUnlock()
	return calls
}

// LastEncodedSegment calls LastEncodedSegmentFunc.
func (mock *ManagerEncoderMock) LastEncodedSegment() uint32 {
	if mock.LastEncodedSegmentFunc == nil {
		panic("ManagerEncoderMock.LastEncodedSegmentFunc: method is nil but ManagerEncoder.LastEncodedSegment was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLastEncodedSegment.Lock()
	mock.calls.LastEncodedSegment = append(mock.calls.LastEncodedSegment, callInfo)
	mock.lockLastEncodedSegment.Unlock()
	return mock.LastEncodedSegmentFunc()
}

// LastEncodedSegmentCalls gets all the calls that were made to LastEncodedSegment.
// Check the length with:
//
//	len(mockedManagerEncoder.LastEncodedSegmentCalls())
func (mock *ManagerEncoderMock) LastEncodedSegmentCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLastEncodedSegment.RLock()
	calls = mock.calls.LastEncodedSegment
	mock.lockLastEncodedSegment.RUnlock()
	return calls
}

// Ensure, that ManagerRefillMock does implement delivery.ManagerRefill.
// If this is not the case, regenerate this file with moq.
var _ delivery.ManagerRefill = &ManagerRefillMock{}

// ManagerRefillMock is a mock implementation of delivery.ManagerRefill.
//
//	func TestSomethingThatUsesManagerRefill(t *testing.T) {
//
//		// make and configure a mocked delivery.ManagerRefill
//		mockedManagerRefill := &ManagerRefillMock{
//			AckFunc: func(segmentKey cppbridge.SegmentKey, s string)  {
//				panic("mock out the Ack method")
//			},
//			BlockIDFunc: func() uuid.UUID {
//				panic("mock out the BlockID method")
//			},
//			DestinationsFunc: func() int {
//				panic("mock out the Destinations method")
//			},
//			GetFunc: func(contextMoqParam context.Context, segmentKey cppbridge.SegmentKey) (delivery.Segment, error) {
//				panic("mock out the Get method")
//			},
//			IntermediateRenameFunc: func() error {
//				panic("mock out the IntermediateRename method")
//			},
//			IsContinuableFunc: func() bool {
//				panic("mock out the IsContinuable method")
//			},
//			LastSegmentFunc: func(v uint16, s string) uint32 {
//				panic("mock out the LastSegment method")
//			},
//			RejectFunc: func(segmentKey cppbridge.SegmentKey, s string)  {
//				panic("mock out the Reject method")
//			},
//			ShardsFunc: func() int {
//				panic("mock out the Shards method")
//			},
//			ShutdownFunc: func(contextMoqParam context.Context) error {
//				panic("mock out the Shutdown method")
//			},
//			WriteAckStatusFunc: func(contextMoqParam context.Context) error {
//				panic("mock out the WriteAckStatus method")
//			},
//			WriteSegmentFunc: func(contextMoqParam context.Context, segmentKey cppbridge.SegmentKey, segment delivery.Segment) error {
//				panic("mock out the WriteSegment method")
//			},
//		}
//
//		// use mockedManagerRefill in code that requires delivery.ManagerRefill
//		// and then make assertions.
//
//	}
type ManagerRefillMock struct {
	// AckFunc mocks the Ack method.
	AckFunc func(segmentKey cppbridge.SegmentKey, s string)

	// BlockIDFunc mocks the BlockID method.
	BlockIDFunc func() uuid.UUID

	// DestinationsFunc mocks the Destinations method.
	DestinationsFunc func() int

	// GetFunc mocks the Get method.
	GetFunc func(contextMoqParam context.Context, segmentKey cppbridge.SegmentKey) (delivery.Segment, error)

	// IntermediateRenameFunc mocks the IntermediateRename method.
	IntermediateRenameFunc func() error

	// IsContinuableFunc mocks the IsContinuable method.
	IsContinuableFunc func() bool

	// LastSegmentFunc mocks the LastSegment method.
	LastSegmentFunc func(v uint16, s string) uint32

	// RejectFunc mocks the Reject method.
	RejectFunc func(segmentKey cppbridge.SegmentKey, s string)

	// ShardsFunc mocks the Shards method.
	ShardsFunc func() int

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func(contextMoqParam context.Context) error

	// WriteAckStatusFunc mocks the WriteAckStatus method.
	WriteAckStatusFunc func(contextMoqParam context.Context) error

	// WriteSegmentFunc mocks the WriteSegment method.
	WriteSegmentFunc func(contextMoqParam context.Context, segmentKey cppbridge.SegmentKey, segment delivery.Segment) error

	// calls tracks calls to the methods.
	calls struct {
		// Ack holds details about calls to the Ack method.
		Ack []struct {
			// SegmentKey is the segmentKey argument value.
			SegmentKey cppbridge.SegmentKey
			// S is the s argument value.
			S string
		}
		// BlockID holds details about calls to the BlockID method.
		BlockID []struct {
		}
		// Destinations holds details about calls to the Destinations method.
		Destinations []struct {
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SegmentKey is the segmentKey argument value.
			SegmentKey cppbridge.SegmentKey
		}
		// IntermediateRename holds details about calls to the IntermediateRename method.
		IntermediateRename []struct {
		}
		// IsContinuable holds details about calls to the IsContinuable method.
		IsContinuable []struct {
		}
		// LastSegment holds details about calls to the LastSegment method.
		LastSegment []struct {
			// V is the v argument value.
			V uint16
			// S is the s argument value.
			S string
		}
		// Reject holds details about calls to the Reject method.
		Reject []struct {
			// SegmentKey is the segmentKey argument value.
			SegmentKey cppbridge.SegmentKey
			// S is the s argument value.
			S string
		}
		// Shards holds details about calls to the Shards method.
		Shards []struct {
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// WriteAckStatus holds details about calls to the WriteAckStatus method.
		WriteAckStatus []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// WriteSegment holds details about calls to the WriteSegment method.
		WriteSegment []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SegmentKey is the segmentKey argument value.
			SegmentKey cppbridge.SegmentKey
			// Segment is the segment argument value.
			Segment delivery.Segment
		}
	}
	lockAck                sync.RWMutex
	lockBlockID            sync.RWMutex
	lockDestinations       sync.RWMutex
	lockGet                sync.RWMutex
	lockIntermediateRename sync.RWMutex
	lockIsContinuable      sync.RWMutex
	lockLastSegment        sync.RWMutex
	lockReject             sync.RWMutex
	lockShards             sync.RWMutex
	lockShutdown           sync.RWMutex
	lockWriteAckStatus     sync.RWMutex
	lockWriteSegment       sync.RWMutex
}

// Ack calls AckFunc.
func (mock *ManagerRefillMock) Ack(segmentKey cppbridge.SegmentKey, s string) {
	if mock.AckFunc == nil {
		panic("ManagerRefillMock.AckFunc: method is nil but ManagerRefill.Ack was just called")
	}
	callInfo := struct {
		SegmentKey cppbridge.SegmentKey
		S          string
	}{
		SegmentKey: segmentKey,
		S:          s,
	}
	mock.lockAck.Lock()
	mock.calls.Ack = append(mock.calls.Ack, callInfo)
	mock.lockAck.Unlock()
	mock.AckFunc(segmentKey, s)
}

// AckCalls gets all the calls that were made to Ack.
// Check the length with:
//
//	len(mockedManagerRefill.AckCalls())
func (mock *ManagerRefillMock) AckCalls() []struct {
	SegmentKey cppbridge.SegmentKey
	S          string
} {
	var calls []struct {
		SegmentKey cppbridge.SegmentKey
		S          string
	}
	mock.lockAck.RLock()
	calls = mock.calls.Ack
	mock.lockAck.RUnlock()
	return calls
}

// BlockID calls BlockIDFunc.
func (mock *ManagerRefillMock) BlockID() uuid.UUID {
	if mock.BlockIDFunc == nil {
		panic("ManagerRefillMock.BlockIDFunc: method is nil but ManagerRefill.BlockID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBlockID.Lock()
	mock.calls.BlockID = append(mock.calls.BlockID, callInfo)
	mock.lockBlockID.Unlock()
	return mock.BlockIDFunc()
}

// BlockIDCalls gets all the calls that were made to BlockID.
// Check the length with:
//
//	len(mockedManagerRefill.BlockIDCalls())
func (mock *ManagerRefillMock) BlockIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBlockID.RLock()
	calls = mock.calls.BlockID
	mock.lockBlockID.RUnlock()
	return calls
}

// Destinations calls DestinationsFunc.
func (mock *ManagerRefillMock) Destinations() int {
	if mock.DestinationsFunc == nil {
		panic("ManagerRefillMock.DestinationsFunc: method is nil but ManagerRefill.Destinations was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDestinations.Lock()
	mock.calls.Destinations = append(mock.calls.Destinations, callInfo)
	mock.lockDestinations.Unlock()
	return mock.DestinationsFunc()
}

// DestinationsCalls gets all the calls that were made to Destinations.
// Check the length with:
//
//	len(mockedManagerRefill.DestinationsCalls())
func (mock *ManagerRefillMock) DestinationsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDestinations.RLock()
	calls = mock.calls.Destinations
	mock.lockDestinations.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *ManagerRefillMock) Get(contextMoqParam context.Context, segmentKey cppbridge.SegmentKey) (delivery.Segment, error) {
	if mock.GetFunc == nil {
		panic("ManagerRefillMock.GetFunc: method is nil but ManagerRefill.Get was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		SegmentKey      cppbridge.SegmentKey
	}{
		ContextMoqParam: contextMoqParam,
		SegmentKey:      segmentKey,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(contextMoqParam, segmentKey)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedManagerRefill.GetCalls())
func (mock *ManagerRefillMock) GetCalls() []struct {
	ContextMoqParam context.Context
	SegmentKey      cppbridge.SegmentKey
} {
	var calls []struct {
		ContextMoqParam context.Context
		SegmentKey      cppbridge.SegmentKey
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// IntermediateRename calls IntermediateRenameFunc.
func (mock *ManagerRefillMock) IntermediateRename() error {
	if mock.IntermediateRenameFunc == nil {
		panic("ManagerRefillMock.IntermediateRenameFunc: method is nil but ManagerRefill.IntermediateRename was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIntermediateRename.Lock()
	mock.calls.IntermediateRename = append(mock.calls.IntermediateRename, callInfo)
	mock.lockIntermediateRename.Unlock()
	return mock.IntermediateRenameFunc()
}

// IntermediateRenameCalls gets all the calls that were made to IntermediateRename.
// Check the length with:
//
//	len(mockedManagerRefill.IntermediateRenameCalls())
func (mock *ManagerRefillMock) IntermediateRenameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIntermediateRename.RLock()
	calls = mock.calls.IntermediateRename
	mock.lockIntermediateRename.RUnlock()
	return calls
}

// IsContinuable calls IsContinuableFunc.
func (mock *ManagerRefillMock) IsContinuable() bool {
	if mock.IsContinuableFunc == nil {
		panic("ManagerRefillMock.IsContinuableFunc: method is nil but ManagerRefill.IsContinuable was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsContinuable.Lock()
	mock.calls.IsContinuable = append(mock.calls.IsContinuable, callInfo)
	mock.lockIsContinuable.Unlock()
	return mock.IsContinuableFunc()
}

// IsContinuableCalls gets all the calls that were made to IsContinuable.
// Check the length with:
//
//	len(mockedManagerRefill.IsContinuableCalls())
func (mock *ManagerRefillMock) IsContinuableCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsContinuable.RLock()
	calls = mock.calls.IsContinuable
	mock.lockIsContinuable.RUnlock()
	return calls
}

// LastSegment calls LastSegmentFunc.
func (mock *ManagerRefillMock) LastSegment(v uint16, s string) uint32 {
	if mock.LastSegmentFunc == nil {
		panic("ManagerRefillMock.LastSegmentFunc: method is nil but ManagerRefill.LastSegment was just called")
	}
	callInfo := struct {
		V uint16
		S string
	}{
		V: v,
		S: s,
	}
	mock.lockLastSegment.Lock()
	mock.calls.LastSegment = append(mock.calls.LastSegment, callInfo)
	mock.lockLastSegment.Unlock()
	return mock.LastSegmentFunc(v, s)
}

// LastSegmentCalls gets all the calls that were made to LastSegment.
// Check the length with:
//
//	len(mockedManagerRefill.LastSegmentCalls())
func (mock *ManagerRefillMock) LastSegmentCalls() []struct {
	V uint16
	S string
} {
	var calls []struct {
		V uint16
		S string
	}
	mock.lockLastSegment.RLock()
	calls = mock.calls.LastSegment
	mock.lockLastSegment.RUnlock()
	return calls
}

// Reject calls RejectFunc.
func (mock *ManagerRefillMock) Reject(segmentKey cppbridge.SegmentKey, s string) {
	if mock.RejectFunc == nil {
		panic("ManagerRefillMock.RejectFunc: method is nil but ManagerRefill.Reject was just called")
	}
	callInfo := struct {
		SegmentKey cppbridge.SegmentKey
		S          string
	}{
		SegmentKey: segmentKey,
		S:          s,
	}
	mock.lockReject.Lock()
	mock.calls.Reject = append(mock.calls.Reject, callInfo)
	mock.lockReject.Unlock()
	mock.RejectFunc(segmentKey, s)
}

// RejectCalls gets all the calls that were made to Reject.
// Check the length with:
//
//	len(mockedManagerRefill.RejectCalls())
func (mock *ManagerRefillMock) RejectCalls() []struct {
	SegmentKey cppbridge.SegmentKey
	S          string
} {
	var calls []struct {
		SegmentKey cppbridge.SegmentKey
		S          string
	}
	mock.lockReject.RLock()
	calls = mock.calls.Reject
	mock.lockReject.RUnlock()
	return calls
}

// Shards calls ShardsFunc.
func (mock *ManagerRefillMock) Shards() int {
	if mock.ShardsFunc == nil {
		panic("ManagerRefillMock.ShardsFunc: method is nil but ManagerRefill.Shards was just called")
	}
	callInfo := struct {
	}{}
	mock.lockShards.Lock()
	mock.calls.Shards = append(mock.calls.Shards, callInfo)
	mock.lockShards.Unlock()
	return mock.ShardsFunc()
}

// ShardsCalls gets all the calls that were made to Shards.
// Check the length with:
//
//	len(mockedManagerRefill.ShardsCalls())
func (mock *ManagerRefillMock) ShardsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockShards.RLock()
	calls = mock.calls.Shards
	mock.lockShards.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *ManagerRefillMock) Shutdown(contextMoqParam context.Context) error {
	if mock.ShutdownFunc == nil {
		panic("ManagerRefillMock.ShutdownFunc: method is nil but ManagerRefill.Shutdown was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	mock.lockShutdown.Unlock()
	return mock.ShutdownFunc(contextMoqParam)
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//
//	len(mockedManagerRefill.ShutdownCalls())
func (mock *ManagerRefillMock) ShutdownCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockShutdown.RLock()
	calls = mock.calls.Shutdown
	mock.lockShutdown.RUnlock()
	return calls
}

// WriteAckStatus calls WriteAckStatusFunc.
func (mock *ManagerRefillMock) WriteAckStatus(contextMoqParam context.Context) error {
	if mock.WriteAckStatusFunc == nil {
		panic("ManagerRefillMock.WriteAckStatusFunc: method is nil but ManagerRefill.WriteAckStatus was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockWriteAckStatus.Lock()
	mock.calls.WriteAckStatus = append(mock.calls.WriteAckStatus, callInfo)
	mock.lockWriteAckStatus.Unlock()
	return mock.WriteAckStatusFunc(contextMoqParam)
}

// WriteAckStatusCalls gets all the calls that were made to WriteAckStatus.
// Check the length with:
//
//	len(mockedManagerRefill.WriteAckStatusCalls())
func (mock *ManagerRefillMock) WriteAckStatusCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockWriteAckStatus.RLock()
	calls = mock.calls.WriteAckStatus
	mock.lockWriteAckStatus.RUnlock()
	return calls
}

// WriteSegment calls WriteSegmentFunc.
func (mock *ManagerRefillMock) WriteSegment(contextMoqParam context.Context, segmentKey cppbridge.SegmentKey, segment delivery.Segment) error {
	if mock.WriteSegmentFunc == nil {
		panic("ManagerRefillMock.WriteSegmentFunc: method is nil but ManagerRefill.WriteSegment was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		SegmentKey      cppbridge.SegmentKey
		Segment         delivery.Segment
	}{
		ContextMoqParam: contextMoqParam,
		SegmentKey:      segmentKey,
		Segment:         segment,
	}
	mock.lockWriteSegment.Lock()
	mock.calls.WriteSegment = append(mock.calls.WriteSegment, callInfo)
	mock.lockWriteSegment.Unlock()
	return mock.WriteSegmentFunc(contextMoqParam, segmentKey, segment)
}

// WriteSegmentCalls gets all the calls that were made to WriteSegment.
// Check the length with:
//
//	len(mockedManagerRefill.WriteSegmentCalls())
func (mock *ManagerRefillMock) WriteSegmentCalls() []struct {
	ContextMoqParam context.Context
	SegmentKey      cppbridge.SegmentKey
	Segment         delivery.Segment
} {
	var calls []struct {
		ContextMoqParam context.Context
		SegmentKey      cppbridge.SegmentKey
		Segment         delivery.Segment
	}
	mock.lockWriteSegment.RLock()
	calls = mock.calls.WriteSegment
	mock.lockWriteSegment.RUnlock()
	return calls
}

// Ensure, that RejectNotifyerMock does implement delivery.RejectNotifyer.
// If this is not the case, regenerate this file with moq.
var _ delivery.RejectNotifyer = &RejectNotifyerMock{}

// RejectNotifyerMock is a mock implementation of delivery.RejectNotifyer.
//
//	func TestSomethingThatUsesRejectNotifyer(t *testing.T) {
//
//		// make and configure a mocked delivery.RejectNotifyer
//		mockedRejectNotifyer := &RejectNotifyerMock{
//			NotifyOnRejectFunc: func()  {
//				panic("mock out the NotifyOnReject method")
//			},
//		}
//
//		// use mockedRejectNotifyer in code that requires delivery.RejectNotifyer
//		// and then make assertions.
//
//	}
type RejectNotifyerMock struct {
	// NotifyOnRejectFunc mocks the NotifyOnReject method.
	NotifyOnRejectFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// NotifyOnReject holds details about calls to the NotifyOnReject method.
		NotifyOnReject []struct {
		}
	}
	lockNotifyOnReject sync.RWMutex
}

// NotifyOnReject calls NotifyOnRejectFunc.
func (mock *RejectNotifyerMock) NotifyOnReject() {
	if mock.NotifyOnRejectFunc == nil {
		panic("RejectNotifyerMock.NotifyOnRejectFunc: method is nil but RejectNotifyer.NotifyOnReject was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNotifyOnReject.Lock()
	mock.calls.NotifyOnReject = append(mock.calls.NotifyOnReject, callInfo)
	mock.lockNotifyOnReject.Unlock()
	mock.NotifyOnRejectFunc()
}

// NotifyOnRejectCalls gets all the calls that were made to NotifyOnReject.
// Check the length with:
//
//	len(mockedRejectNotifyer.NotifyOnRejectCalls())
func (mock *RejectNotifyerMock) NotifyOnRejectCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNotifyOnReject.RLock()
	calls = mock.calls.NotifyOnReject
	mock.lockNotifyOnReject.RUnlock()
	return calls
}

// Ensure, that SourceMock does implement delivery.Source.
// If this is not the case, regenerate this file with moq.
var _ delivery.Source = &SourceMock{}

// SourceMock is a mock implementation of delivery.Source.
//
//	func TestSomethingThatUsesSource(t *testing.T) {
//
//		// make and configure a mocked delivery.Source
//		mockedSource := &SourceMock{
//			AckFunc: func(key cppbridge.SegmentKey, dest string)  {
//				panic("mock out the Ack method")
//			},
//			GetFunc: func(ctx context.Context, key cppbridge.SegmentKey) (delivery.Segment, error) {
//				panic("mock out the Get method")
//			},
//			RejectFunc: func(key cppbridge.SegmentKey, dest string)  {
//				panic("mock out the Reject method")
//			},
//		}
//
//		// use mockedSource in code that requires delivery.Source
//		// and then make assertions.
//
//	}
type SourceMock struct {
	// AckFunc mocks the Ack method.
	AckFunc func(key cppbridge.SegmentKey, dest string)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, key cppbridge.SegmentKey) (delivery.Segment, error)

	// RejectFunc mocks the Reject method.
	RejectFunc func(key cppbridge.SegmentKey, dest string)

	// calls tracks calls to the methods.
	calls struct {
		// Ack holds details about calls to the Ack method.
		Ack []struct {
			// Key is the key argument value.
			Key cppbridge.SegmentKey
			// Dest is the dest argument value.
			Dest string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key cppbridge.SegmentKey
		}
		// Reject holds details about calls to the Reject method.
		Reject []struct {
			// Key is the key argument value.
			Key cppbridge.SegmentKey
			// Dest is the dest argument value.
			Dest string
		}
	}
	lockAck    sync.RWMutex
	lockGet    sync.RWMutex
	lockReject sync.RWMutex
}

// Ack calls AckFunc.
func (mock *SourceMock) Ack(key cppbridge.SegmentKey, dest string) {
	if mock.AckFunc == nil {
		panic("SourceMock.AckFunc: method is nil but Source.Ack was just called")
	}
	callInfo := struct {
		Key  cppbridge.SegmentKey
		Dest string
	}{
		Key:  key,
		Dest: dest,
	}
	mock.lockAck.Lock()
	mock.calls.Ack = append(mock.calls.Ack, callInfo)
	mock.lockAck.Unlock()
	mock.AckFunc(key, dest)
}

// AckCalls gets all the calls that were made to Ack.
// Check the length with:
//
//	len(mockedSource.AckCalls())
func (mock *SourceMock) AckCalls() []struct {
	Key  cppbridge.SegmentKey
	Dest string
} {
	var calls []struct {
		Key  cppbridge.SegmentKey
		Dest string
	}
	mock.lockAck.RLock()
	calls = mock.calls.Ack
	mock.lockAck.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *SourceMock) Get(ctx context.Context, key cppbridge.SegmentKey) (delivery.Segment, error) {
	if mock.GetFunc == nil {
		panic("SourceMock.GetFunc: method is nil but Source.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key cppbridge.SegmentKey
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedSource.GetCalls())
func (mock *SourceMock) GetCalls() []struct {
	Ctx context.Context
	Key cppbridge.SegmentKey
} {
	var calls []struct {
		Ctx context.Context
		Key cppbridge.SegmentKey
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Reject calls RejectFunc.
func (mock *SourceMock) Reject(key cppbridge.SegmentKey, dest string) {
	if mock.RejectFunc == nil {
		panic("SourceMock.RejectFunc: method is nil but Source.Reject was just called")
	}
	callInfo := struct {
		Key  cppbridge.SegmentKey
		Dest string
	}{
		Key:  key,
		Dest: dest,
	}
	mock.lockReject.Lock()
	mock.calls.Reject = append(mock.calls.Reject, callInfo)
	mock.lockReject.Unlock()
	mock.RejectFunc(key, dest)
}

// RejectCalls gets all the calls that were made to Reject.
// Check the length with:
//
//	len(mockedSource.RejectCalls())
func (mock *SourceMock) RejectCalls() []struct {
	Key  cppbridge.SegmentKey
	Dest string
} {
	var calls []struct {
		Key  cppbridge.SegmentKey
		Dest string
	}
	mock.lockReject.RLock()
	calls = mock.calls.Reject
	mock.lockReject.RUnlock()
	return calls
}
