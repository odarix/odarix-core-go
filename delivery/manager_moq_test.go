// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package delivery_test

import (
	"context"
	"github.com/google/uuid"
	"github.com/odarix/odarix-core-go/common"
	"github.com/odarix/odarix-core-go/delivery"
	"sync"
)

// Ensure, that DialerMock does implement delivery.Dialer.
// If this is not the case, regenerate this file with moq.
var _ delivery.Dialer = &DialerMock{}

// DialerMock is a mock implementation of delivery.Dialer.
//
//	func TestSomethingThatUsesDialer(t *testing.T) {
//
//		// make and configure a mocked delivery.Dialer
//		mockedDialer := &DialerMock{
//			DialFunc: func(contextMoqParam context.Context) (delivery.Transport, error) {
//				panic("mock out the Dial method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//		}
//
//		// use mockedDialer in code that requires delivery.Dialer
//		// and then make assertions.
//
//	}
type DialerMock struct {
	// DialFunc mocks the Dial method.
	DialFunc func(contextMoqParam context.Context) (delivery.Transport, error)

	// StringFunc mocks the String method.
	StringFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Dial holds details about calls to the Dial method.
		Dial []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// String holds details about calls to the String method.
		String []struct {
		}
	}
	lockDial   sync.RWMutex
	lockString sync.RWMutex
}

// Dial calls DialFunc.
func (mock *DialerMock) Dial(contextMoqParam context.Context) (delivery.Transport, error) {
	if mock.DialFunc == nil {
		panic("DialerMock.DialFunc: method is nil but Dialer.Dial was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockDial.Lock()
	mock.calls.Dial = append(mock.calls.Dial, callInfo)
	mock.lockDial.Unlock()
	return mock.DialFunc(contextMoqParam)
}

// DialCalls gets all the calls that were made to Dial.
// Check the length with:
//
//	len(mockedDialer.DialCalls())
func (mock *DialerMock) DialCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockDial.RLock()
	calls = mock.calls.Dial
	mock.lockDial.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *DialerMock) String() string {
	if mock.StringFunc == nil {
		panic("DialerMock.StringFunc: method is nil but Dialer.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedDialer.StringCalls())
func (mock *DialerMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// Ensure, that TransportMock does implement delivery.Transport.
// If this is not the case, regenerate this file with moq.
var _ delivery.Transport = &TransportMock{}

// TransportMock is a mock implementation of delivery.Transport.
//
//	func TestSomethingThatUsesTransport(t *testing.T) {
//
//		// make and configure a mocked delivery.Transport
//		mockedTransport := &TransportMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			OnAckFunc: func(fn func(uint32))  {
//				panic("mock out the OnAck method")
//			},
//			OnReadErrorFunc: func(fn func(err error))  {
//				panic("mock out the OnReadError method")
//			},
//			OnRejectFunc: func(fn func(uint32))  {
//				panic("mock out the OnReject method")
//			},
//			SendDrySegmentFunc: func(contextMoqParam context.Context, segment common.Segment) error {
//				panic("mock out the SendDrySegment method")
//			},
//			SendRefillFunc: func(contextMoqParam context.Context, preparedDatas []delivery.PreparedData) error {
//				panic("mock out the SendRefill method")
//			},
//			SendRestoreFunc: func(contextMoqParam context.Context, snapshot common.Snapshot, segments []common.Segment) error {
//				panic("mock out the SendRestore method")
//			},
//			SendSegmentFunc: func(contextMoqParam context.Context, segment common.Segment) error {
//				panic("mock out the SendSegment method")
//			},
//			SendSnapshotFunc: func(contextMoqParam context.Context, snapshot common.Snapshot) error {
//				panic("mock out the SendSnapshot method")
//			},
//		}
//
//		// use mockedTransport in code that requires delivery.Transport
//		// and then make assertions.
//
//	}
type TransportMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// OnAckFunc mocks the OnAck method.
	OnAckFunc func(fn func(uint32))

	// OnReadErrorFunc mocks the OnReadError method.
	OnReadErrorFunc func(fn func(err error))

	// OnRejectFunc mocks the OnReject method.
	OnRejectFunc func(fn func(uint32))

	// SendDrySegmentFunc mocks the SendDrySegment method.
	SendDrySegmentFunc func(contextMoqParam context.Context, segment common.Segment) error

	// SendRefillFunc mocks the SendRefill method.
	SendRefillFunc func(contextMoqParam context.Context, preparedDatas []delivery.PreparedData) error

	// SendRestoreFunc mocks the SendRestore method.
	SendRestoreFunc func(contextMoqParam context.Context, snapshot common.Snapshot, segments []common.Segment) error

	// SendSegmentFunc mocks the SendSegment method.
	SendSegmentFunc func(contextMoqParam context.Context, segment common.Segment) error

	// SendSnapshotFunc mocks the SendSnapshot method.
	SendSnapshotFunc func(contextMoqParam context.Context, snapshot common.Snapshot) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// OnAck holds details about calls to the OnAck method.
		OnAck []struct {
			// Fn is the fn argument value.
			Fn func(uint32)
		}
		// OnReadError holds details about calls to the OnReadError method.
		OnReadError []struct {
			// Fn is the fn argument value.
			Fn func(err error)
		}
		// OnReject holds details about calls to the OnReject method.
		OnReject []struct {
			// Fn is the fn argument value.
			Fn func(uint32)
		}
		// SendDrySegment holds details about calls to the SendDrySegment method.
		SendDrySegment []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Segment is the segment argument value.
			Segment common.Segment
		}
		// SendRefill holds details about calls to the SendRefill method.
		SendRefill []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// PreparedDatas is the preparedDatas argument value.
			PreparedDatas []delivery.PreparedData
		}
		// SendRestore holds details about calls to the SendRestore method.
		SendRestore []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Snapshot is the snapshot argument value.
			Snapshot common.Snapshot
			// Segments is the segments argument value.
			Segments []common.Segment
		}
		// SendSegment holds details about calls to the SendSegment method.
		SendSegment []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Segment is the segment argument value.
			Segment common.Segment
		}
		// SendSnapshot holds details about calls to the SendSnapshot method.
		SendSnapshot []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Snapshot is the snapshot argument value.
			Snapshot common.Snapshot
		}
	}
	lockClose          sync.RWMutex
	lockOnAck          sync.RWMutex
	lockOnReadError    sync.RWMutex
	lockOnReject       sync.RWMutex
	lockSendDrySegment sync.RWMutex
	lockSendRefill     sync.RWMutex
	lockSendRestore    sync.RWMutex
	lockSendSegment    sync.RWMutex
	lockSendSnapshot   sync.RWMutex
}

// Close calls CloseFunc.
func (mock *TransportMock) Close() error {
	if mock.CloseFunc == nil {
		panic("TransportMock.CloseFunc: method is nil but Transport.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedTransport.CloseCalls())
func (mock *TransportMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// OnAck calls OnAckFunc.
func (mock *TransportMock) OnAck(fn func(uint32)) {
	if mock.OnAckFunc == nil {
		panic("TransportMock.OnAckFunc: method is nil but Transport.OnAck was just called")
	}
	callInfo := struct {
		Fn func(uint32)
	}{
		Fn: fn,
	}
	mock.lockOnAck.Lock()
	mock.calls.OnAck = append(mock.calls.OnAck, callInfo)
	mock.lockOnAck.Unlock()
	mock.OnAckFunc(fn)
}

// OnAckCalls gets all the calls that were made to OnAck.
// Check the length with:
//
//	len(mockedTransport.OnAckCalls())
func (mock *TransportMock) OnAckCalls() []struct {
	Fn func(uint32)
} {
	var calls []struct {
		Fn func(uint32)
	}
	mock.lockOnAck.RLock()
	calls = mock.calls.OnAck
	mock.lockOnAck.RUnlock()
	return calls
}

// OnReadError calls OnReadErrorFunc.
func (mock *TransportMock) OnReadError(fn func(err error)) {
	if mock.OnReadErrorFunc == nil {
		panic("TransportMock.OnReadErrorFunc: method is nil but Transport.OnReadError was just called")
	}
	callInfo := struct {
		Fn func(err error)
	}{
		Fn: fn,
	}
	mock.lockOnReadError.Lock()
	mock.calls.OnReadError = append(mock.calls.OnReadError, callInfo)
	mock.lockOnReadError.Unlock()
	mock.OnReadErrorFunc(fn)
}

// OnReadErrorCalls gets all the calls that were made to OnReadError.
// Check the length with:
//
//	len(mockedTransport.OnReadErrorCalls())
func (mock *TransportMock) OnReadErrorCalls() []struct {
	Fn func(err error)
} {
	var calls []struct {
		Fn func(err error)
	}
	mock.lockOnReadError.RLock()
	calls = mock.calls.OnReadError
	mock.lockOnReadError.RUnlock()
	return calls
}

// OnReject calls OnRejectFunc.
func (mock *TransportMock) OnReject(fn func(uint32)) {
	if mock.OnRejectFunc == nil {
		panic("TransportMock.OnRejectFunc: method is nil but Transport.OnReject was just called")
	}
	callInfo := struct {
		Fn func(uint32)
	}{
		Fn: fn,
	}
	mock.lockOnReject.Lock()
	mock.calls.OnReject = append(mock.calls.OnReject, callInfo)
	mock.lockOnReject.Unlock()
	mock.OnRejectFunc(fn)
}

// OnRejectCalls gets all the calls that were made to OnReject.
// Check the length with:
//
//	len(mockedTransport.OnRejectCalls())
func (mock *TransportMock) OnRejectCalls() []struct {
	Fn func(uint32)
} {
	var calls []struct {
		Fn func(uint32)
	}
	mock.lockOnReject.RLock()
	calls = mock.calls.OnReject
	mock.lockOnReject.RUnlock()
	return calls
}

// SendDrySegment calls SendDrySegmentFunc.
func (mock *TransportMock) SendDrySegment(contextMoqParam context.Context, segment common.Segment) error {
	if mock.SendDrySegmentFunc == nil {
		panic("TransportMock.SendDrySegmentFunc: method is nil but Transport.SendDrySegment was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Segment         common.Segment
	}{
		ContextMoqParam: contextMoqParam,
		Segment:         segment,
	}
	mock.lockSendDrySegment.Lock()
	mock.calls.SendDrySegment = append(mock.calls.SendDrySegment, callInfo)
	mock.lockSendDrySegment.Unlock()
	return mock.SendDrySegmentFunc(contextMoqParam, segment)
}

// SendDrySegmentCalls gets all the calls that were made to SendDrySegment.
// Check the length with:
//
//	len(mockedTransport.SendDrySegmentCalls())
func (mock *TransportMock) SendDrySegmentCalls() []struct {
	ContextMoqParam context.Context
	Segment         common.Segment
} {
	var calls []struct {
		ContextMoqParam context.Context
		Segment         common.Segment
	}
	mock.lockSendDrySegment.RLock()
	calls = mock.calls.SendDrySegment
	mock.lockSendDrySegment.RUnlock()
	return calls
}

// SendRefill calls SendRefillFunc.
func (mock *TransportMock) SendRefill(contextMoqParam context.Context, preparedDatas []delivery.PreparedData) error {
	if mock.SendRefillFunc == nil {
		panic("TransportMock.SendRefillFunc: method is nil but Transport.SendRefill was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		PreparedDatas   []delivery.PreparedData
	}{
		ContextMoqParam: contextMoqParam,
		PreparedDatas:   preparedDatas,
	}
	mock.lockSendRefill.Lock()
	mock.calls.SendRefill = append(mock.calls.SendRefill, callInfo)
	mock.lockSendRefill.Unlock()
	return mock.SendRefillFunc(contextMoqParam, preparedDatas)
}

// SendRefillCalls gets all the calls that were made to SendRefill.
// Check the length with:
//
//	len(mockedTransport.SendRefillCalls())
func (mock *TransportMock) SendRefillCalls() []struct {
	ContextMoqParam context.Context
	PreparedDatas   []delivery.PreparedData
} {
	var calls []struct {
		ContextMoqParam context.Context
		PreparedDatas   []delivery.PreparedData
	}
	mock.lockSendRefill.RLock()
	calls = mock.calls.SendRefill
	mock.lockSendRefill.RUnlock()
	return calls
}

// SendRestore calls SendRestoreFunc.
func (mock *TransportMock) SendRestore(contextMoqParam context.Context, snapshot common.Snapshot, segments []common.Segment) error {
	if mock.SendRestoreFunc == nil {
		panic("TransportMock.SendRestoreFunc: method is nil but Transport.SendRestore was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Snapshot        common.Snapshot
		Segments        []common.Segment
	}{
		ContextMoqParam: contextMoqParam,
		Snapshot:        snapshot,
		Segments:        segments,
	}
	mock.lockSendRestore.Lock()
	mock.calls.SendRestore = append(mock.calls.SendRestore, callInfo)
	mock.lockSendRestore.Unlock()
	return mock.SendRestoreFunc(contextMoqParam, snapshot, segments)
}

// SendRestoreCalls gets all the calls that were made to SendRestore.
// Check the length with:
//
//	len(mockedTransport.SendRestoreCalls())
func (mock *TransportMock) SendRestoreCalls() []struct {
	ContextMoqParam context.Context
	Snapshot        common.Snapshot
	Segments        []common.Segment
} {
	var calls []struct {
		ContextMoqParam context.Context
		Snapshot        common.Snapshot
		Segments        []common.Segment
	}
	mock.lockSendRestore.RLock()
	calls = mock.calls.SendRestore
	mock.lockSendRestore.RUnlock()
	return calls
}

// SendSegment calls SendSegmentFunc.
func (mock *TransportMock) SendSegment(contextMoqParam context.Context, segment common.Segment) error {
	if mock.SendSegmentFunc == nil {
		panic("TransportMock.SendSegmentFunc: method is nil but Transport.SendSegment was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Segment         common.Segment
	}{
		ContextMoqParam: contextMoqParam,
		Segment:         segment,
	}
	mock.lockSendSegment.Lock()
	mock.calls.SendSegment = append(mock.calls.SendSegment, callInfo)
	mock.lockSendSegment.Unlock()
	return mock.SendSegmentFunc(contextMoqParam, segment)
}

// SendSegmentCalls gets all the calls that were made to SendSegment.
// Check the length with:
//
//	len(mockedTransport.SendSegmentCalls())
func (mock *TransportMock) SendSegmentCalls() []struct {
	ContextMoqParam context.Context
	Segment         common.Segment
} {
	var calls []struct {
		ContextMoqParam context.Context
		Segment         common.Segment
	}
	mock.lockSendSegment.RLock()
	calls = mock.calls.SendSegment
	mock.lockSendSegment.RUnlock()
	return calls
}

// SendSnapshot calls SendSnapshotFunc.
func (mock *TransportMock) SendSnapshot(contextMoqParam context.Context, snapshot common.Snapshot) error {
	if mock.SendSnapshotFunc == nil {
		panic("TransportMock.SendSnapshotFunc: method is nil but Transport.SendSnapshot was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Snapshot        common.Snapshot
	}{
		ContextMoqParam: contextMoqParam,
		Snapshot:        snapshot,
	}
	mock.lockSendSnapshot.Lock()
	mock.calls.SendSnapshot = append(mock.calls.SendSnapshot, callInfo)
	mock.lockSendSnapshot.Unlock()
	return mock.SendSnapshotFunc(contextMoqParam, snapshot)
}

// SendSnapshotCalls gets all the calls that were made to SendSnapshot.
// Check the length with:
//
//	len(mockedTransport.SendSnapshotCalls())
func (mock *TransportMock) SendSnapshotCalls() []struct {
	ContextMoqParam context.Context
	Snapshot        common.Snapshot
} {
	var calls []struct {
		ContextMoqParam context.Context
		Snapshot        common.Snapshot
	}
	mock.lockSendSnapshot.RLock()
	calls = mock.calls.SendSnapshot
	mock.lockSendSnapshot.RUnlock()
	return calls
}

// Ensure, that ManagerEncoderMock does implement delivery.ManagerEncoder.
// If this is not the case, regenerate this file with moq.
var _ delivery.ManagerEncoder = &ManagerEncoderMock{}

// ManagerEncoderMock is a mock implementation of delivery.ManagerEncoder.
//
//	func TestSomethingThatUsesManagerEncoder(t *testing.T) {
//
//		// make and configure a mocked delivery.ManagerEncoder
//		mockedManagerEncoder := &ManagerEncoderMock{
//			DestroyFunc: func()  {
//				panic("mock out the Destroy method")
//			},
//			EncodeFunc: func(contextMoqParam context.Context, shardedData common.ShardedData) (common.SegmentKey, common.Segment, common.Redundant, error) {
//				panic("mock out the Encode method")
//			},
//			LastEncodedSegmentFunc: func() uint32 {
//				panic("mock out the LastEncodedSegment method")
//			},
//			SnapshotFunc: func(contextMoqParam context.Context, redundants []common.Redundant) (common.Snapshot, error) {
//				panic("mock out the Snapshot method")
//			},
//		}
//
//		// use mockedManagerEncoder in code that requires delivery.ManagerEncoder
//		// and then make assertions.
//
//	}
type ManagerEncoderMock struct {
	// DestroyFunc mocks the Destroy method.
	DestroyFunc func()

	// EncodeFunc mocks the Encode method.
	EncodeFunc func(contextMoqParam context.Context, shardedData common.ShardedData) (common.SegmentKey, common.Segment, common.Redundant, error)

	// LastEncodedSegmentFunc mocks the LastEncodedSegment method.
	LastEncodedSegmentFunc func() uint32

	// SnapshotFunc mocks the Snapshot method.
	SnapshotFunc func(contextMoqParam context.Context, redundants []common.Redundant) (common.Snapshot, error)

	// calls tracks calls to the methods.
	calls struct {
		// Destroy holds details about calls to the Destroy method.
		Destroy []struct {
		}
		// Encode holds details about calls to the Encode method.
		Encode []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// ShardedData is the shardedData argument value.
			ShardedData common.ShardedData
		}
		// LastEncodedSegment holds details about calls to the LastEncodedSegment method.
		LastEncodedSegment []struct {
		}
		// Snapshot holds details about calls to the Snapshot method.
		Snapshot []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Redundants is the redundants argument value.
			Redundants []common.Redundant
		}
	}
	lockDestroy            sync.RWMutex
	lockEncode             sync.RWMutex
	lockLastEncodedSegment sync.RWMutex
	lockSnapshot           sync.RWMutex
}

// Destroy calls DestroyFunc.
func (mock *ManagerEncoderMock) Destroy() {
	if mock.DestroyFunc == nil {
		panic("ManagerEncoderMock.DestroyFunc: method is nil but ManagerEncoder.Destroy was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDestroy.Lock()
	mock.calls.Destroy = append(mock.calls.Destroy, callInfo)
	mock.lockDestroy.Unlock()
	mock.DestroyFunc()
}

// DestroyCalls gets all the calls that were made to Destroy.
// Check the length with:
//
//	len(mockedManagerEncoder.DestroyCalls())
func (mock *ManagerEncoderMock) DestroyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDestroy.RLock()
	calls = mock.calls.Destroy
	mock.lockDestroy.RUnlock()
	return calls
}

// Encode calls EncodeFunc.
func (mock *ManagerEncoderMock) Encode(contextMoqParam context.Context, shardedData common.ShardedData) (common.SegmentKey, common.Segment, common.Redundant, error) {
	if mock.EncodeFunc == nil {
		panic("ManagerEncoderMock.EncodeFunc: method is nil but ManagerEncoder.Encode was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		ShardedData     common.ShardedData
	}{
		ContextMoqParam: contextMoqParam,
		ShardedData:     shardedData,
	}
	mock.lockEncode.Lock()
	mock.calls.Encode = append(mock.calls.Encode, callInfo)
	mock.lockEncode.Unlock()
	return mock.EncodeFunc(contextMoqParam, shardedData)
}

// EncodeCalls gets all the calls that were made to Encode.
// Check the length with:
//
//	len(mockedManagerEncoder.EncodeCalls())
func (mock *ManagerEncoderMock) EncodeCalls() []struct {
	ContextMoqParam context.Context
	ShardedData     common.ShardedData
} {
	var calls []struct {
		ContextMoqParam context.Context
		ShardedData     common.ShardedData
	}
	mock.lockEncode.RLock()
	calls = mock.calls.Encode
	mock.lockEncode.RUnlock()
	return calls
}

// LastEncodedSegment calls LastEncodedSegmentFunc.
func (mock *ManagerEncoderMock) LastEncodedSegment() uint32 {
	if mock.LastEncodedSegmentFunc == nil {
		panic("ManagerEncoderMock.LastEncodedSegmentFunc: method is nil but ManagerEncoder.LastEncodedSegment was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLastEncodedSegment.Lock()
	mock.calls.LastEncodedSegment = append(mock.calls.LastEncodedSegment, callInfo)
	mock.lockLastEncodedSegment.Unlock()
	return mock.LastEncodedSegmentFunc()
}

// LastEncodedSegmentCalls gets all the calls that were made to LastEncodedSegment.
// Check the length with:
//
//	len(mockedManagerEncoder.LastEncodedSegmentCalls())
func (mock *ManagerEncoderMock) LastEncodedSegmentCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLastEncodedSegment.RLock()
	calls = mock.calls.LastEncodedSegment
	mock.lockLastEncodedSegment.RUnlock()
	return calls
}

// Snapshot calls SnapshotFunc.
func (mock *ManagerEncoderMock) Snapshot(contextMoqParam context.Context, redundants []common.Redundant) (common.Snapshot, error) {
	if mock.SnapshotFunc == nil {
		panic("ManagerEncoderMock.SnapshotFunc: method is nil but ManagerEncoder.Snapshot was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Redundants      []common.Redundant
	}{
		ContextMoqParam: contextMoqParam,
		Redundants:      redundants,
	}
	mock.lockSnapshot.Lock()
	mock.calls.Snapshot = append(mock.calls.Snapshot, callInfo)
	mock.lockSnapshot.Unlock()
	return mock.SnapshotFunc(contextMoqParam, redundants)
}

// SnapshotCalls gets all the calls that were made to Snapshot.
// Check the length with:
//
//	len(mockedManagerEncoder.SnapshotCalls())
func (mock *ManagerEncoderMock) SnapshotCalls() []struct {
	ContextMoqParam context.Context
	Redundants      []common.Redundant
} {
	var calls []struct {
		ContextMoqParam context.Context
		Redundants      []common.Redundant
	}
	mock.lockSnapshot.RLock()
	calls = mock.calls.Snapshot
	mock.lockSnapshot.RUnlock()
	return calls
}

// Ensure, that ManagerRefillMock does implement delivery.ManagerRefill.
// If this is not the case, regenerate this file with moq.
var _ delivery.ManagerRefill = &ManagerRefillMock{}

// ManagerRefillMock is a mock implementation of delivery.ManagerRefill.
//
//	func TestSomethingThatUsesManagerRefill(t *testing.T) {
//
//		// make and configure a mocked delivery.ManagerRefill
//		mockedManagerRefill := &ManagerRefillMock{
//			AckFunc: func(segmentKey common.SegmentKey, s string)  {
//				panic("mock out the Ack method")
//			},
//			BlockIDFunc: func() uuid.UUID {
//				panic("mock out the BlockID method")
//			},
//			DestinationsFunc: func() int {
//				panic("mock out the Destinations method")
//			},
//			GetFunc: func(contextMoqParam context.Context, segmentKey common.SegmentKey) (common.Segment, error) {
//				panic("mock out the Get method")
//			},
//			IntermediateRenameFunc: func() error {
//				panic("mock out the IntermediateRename method")
//			},
//			IsContinuableFunc: func() bool {
//				panic("mock out the IsContinuable method")
//			},
//			LastSegmentFunc: func(v uint16, s string) uint32 {
//				panic("mock out the LastSegment method")
//			},
//			RejectFunc: func(segmentKey common.SegmentKey, s string)  {
//				panic("mock out the Reject method")
//			},
//			RestoreFunc: func(contextMoqParam context.Context, segmentKey common.SegmentKey) (common.Snapshot, []common.Segment, error) {
//				panic("mock out the Restore method")
//			},
//			ShardsFunc: func() int {
//				panic("mock out the Shards method")
//			},
//			ShutdownFunc: func(contextMoqParam context.Context) error {
//				panic("mock out the Shutdown method")
//			},
//			WriteAckStatusFunc: func(contextMoqParam context.Context) error {
//				panic("mock out the WriteAckStatus method")
//			},
//			WriteSegmentFunc: func(contextMoqParam context.Context, segmentKey common.SegmentKey, segment common.Segment) error {
//				panic("mock out the WriteSegment method")
//			},
//			WriteSnapshotFunc: func(contextMoqParam context.Context, segmentKey common.SegmentKey, snapshot common.Snapshot) error {
//				panic("mock out the WriteSnapshot method")
//			},
//		}
//
//		// use mockedManagerRefill in code that requires delivery.ManagerRefill
//		// and then make assertions.
//
//	}
type ManagerRefillMock struct {
	// AckFunc mocks the Ack method.
	AckFunc func(segmentKey common.SegmentKey, s string)

	// BlockIDFunc mocks the BlockID method.
	BlockIDFunc func() uuid.UUID

	// DestinationsFunc mocks the Destinations method.
	DestinationsFunc func() int

	// GetFunc mocks the Get method.
	GetFunc func(contextMoqParam context.Context, segmentKey common.SegmentKey) (common.Segment, error)

	// IntermediateRenameFunc mocks the IntermediateRename method.
	IntermediateRenameFunc func() error

	// IsContinuableFunc mocks the IsContinuable method.
	IsContinuableFunc func() bool

	// LastSegmentFunc mocks the LastSegment method.
	LastSegmentFunc func(v uint16, s string) uint32

	// RejectFunc mocks the Reject method.
	RejectFunc func(segmentKey common.SegmentKey, s string)

	// RestoreFunc mocks the Restore method.
	RestoreFunc func(contextMoqParam context.Context, segmentKey common.SegmentKey) (common.Snapshot, []common.Segment, error)

	// ShardsFunc mocks the Shards method.
	ShardsFunc func() int

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func(contextMoqParam context.Context) error

	// WriteAckStatusFunc mocks the WriteAckStatus method.
	WriteAckStatusFunc func(contextMoqParam context.Context) error

	// WriteSegmentFunc mocks the WriteSegment method.
	WriteSegmentFunc func(contextMoqParam context.Context, segmentKey common.SegmentKey, segment common.Segment) error

	// WriteSnapshotFunc mocks the WriteSnapshot method.
	WriteSnapshotFunc func(contextMoqParam context.Context, segmentKey common.SegmentKey, snapshot common.Snapshot) error

	// calls tracks calls to the methods.
	calls struct {
		// Ack holds details about calls to the Ack method.
		Ack []struct {
			// SegmentKey is the segmentKey argument value.
			SegmentKey common.SegmentKey
			// S is the s argument value.
			S string
		}
		// BlockID holds details about calls to the BlockID method.
		BlockID []struct {
		}
		// Destinations holds details about calls to the Destinations method.
		Destinations []struct {
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SegmentKey is the segmentKey argument value.
			SegmentKey common.SegmentKey
		}
		// IntermediateRename holds details about calls to the IntermediateRename method.
		IntermediateRename []struct {
		}
		// IsContinuable holds details about calls to the IsContinuable method.
		IsContinuable []struct {
		}
		// LastSegment holds details about calls to the LastSegment method.
		LastSegment []struct {
			// V is the v argument value.
			V uint16
			// S is the s argument value.
			S string
		}
		// Reject holds details about calls to the Reject method.
		Reject []struct {
			// SegmentKey is the segmentKey argument value.
			SegmentKey common.SegmentKey
			// S is the s argument value.
			S string
		}
		// Restore holds details about calls to the Restore method.
		Restore []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SegmentKey is the segmentKey argument value.
			SegmentKey common.SegmentKey
		}
		// Shards holds details about calls to the Shards method.
		Shards []struct {
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// WriteAckStatus holds details about calls to the WriteAckStatus method.
		WriteAckStatus []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// WriteSegment holds details about calls to the WriteSegment method.
		WriteSegment []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SegmentKey is the segmentKey argument value.
			SegmentKey common.SegmentKey
			// Segment is the segment argument value.
			Segment common.Segment
		}
		// WriteSnapshot holds details about calls to the WriteSnapshot method.
		WriteSnapshot []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SegmentKey is the segmentKey argument value.
			SegmentKey common.SegmentKey
			// Snapshot is the snapshot argument value.
			Snapshot common.Snapshot
		}
	}
	lockAck                sync.RWMutex
	lockBlockID            sync.RWMutex
	lockDestinations       sync.RWMutex
	lockGet                sync.RWMutex
	lockIntermediateRename sync.RWMutex
	lockIsContinuable      sync.RWMutex
	lockLastSegment        sync.RWMutex
	lockReject             sync.RWMutex
	lockRestore            sync.RWMutex
	lockShards             sync.RWMutex
	lockShutdown           sync.RWMutex
	lockWriteAckStatus     sync.RWMutex
	lockWriteSegment       sync.RWMutex
	lockWriteSnapshot      sync.RWMutex
}

// Ack calls AckFunc.
func (mock *ManagerRefillMock) Ack(segmentKey common.SegmentKey, s string) {
	if mock.AckFunc == nil {
		panic("ManagerRefillMock.AckFunc: method is nil but ManagerRefill.Ack was just called")
	}
	callInfo := struct {
		SegmentKey common.SegmentKey
		S          string
	}{
		SegmentKey: segmentKey,
		S:          s,
	}
	mock.lockAck.Lock()
	mock.calls.Ack = append(mock.calls.Ack, callInfo)
	mock.lockAck.Unlock()
	mock.AckFunc(segmentKey, s)
}

// AckCalls gets all the calls that were made to Ack.
// Check the length with:
//
//	len(mockedManagerRefill.AckCalls())
func (mock *ManagerRefillMock) AckCalls() []struct {
	SegmentKey common.SegmentKey
	S          string
} {
	var calls []struct {
		SegmentKey common.SegmentKey
		S          string
	}
	mock.lockAck.RLock()
	calls = mock.calls.Ack
	mock.lockAck.RUnlock()
	return calls
}

// BlockID calls BlockIDFunc.
func (mock *ManagerRefillMock) BlockID() uuid.UUID {
	if mock.BlockIDFunc == nil {
		panic("ManagerRefillMock.BlockIDFunc: method is nil but ManagerRefill.BlockID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBlockID.Lock()
	mock.calls.BlockID = append(mock.calls.BlockID, callInfo)
	mock.lockBlockID.Unlock()
	return mock.BlockIDFunc()
}

// BlockIDCalls gets all the calls that were made to BlockID.
// Check the length with:
//
//	len(mockedManagerRefill.BlockIDCalls())
func (mock *ManagerRefillMock) BlockIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBlockID.RLock()
	calls = mock.calls.BlockID
	mock.lockBlockID.RUnlock()
	return calls
}

// Destinations calls DestinationsFunc.
func (mock *ManagerRefillMock) Destinations() int {
	if mock.DestinationsFunc == nil {
		panic("ManagerRefillMock.DestinationsFunc: method is nil but ManagerRefill.Destinations was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDestinations.Lock()
	mock.calls.Destinations = append(mock.calls.Destinations, callInfo)
	mock.lockDestinations.Unlock()
	return mock.DestinationsFunc()
}

// DestinationsCalls gets all the calls that were made to Destinations.
// Check the length with:
//
//	len(mockedManagerRefill.DestinationsCalls())
func (mock *ManagerRefillMock) DestinationsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDestinations.RLock()
	calls = mock.calls.Destinations
	mock.lockDestinations.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *ManagerRefillMock) Get(contextMoqParam context.Context, segmentKey common.SegmentKey) (common.Segment, error) {
	if mock.GetFunc == nil {
		panic("ManagerRefillMock.GetFunc: method is nil but ManagerRefill.Get was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		SegmentKey      common.SegmentKey
	}{
		ContextMoqParam: contextMoqParam,
		SegmentKey:      segmentKey,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(contextMoqParam, segmentKey)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedManagerRefill.GetCalls())
func (mock *ManagerRefillMock) GetCalls() []struct {
	ContextMoqParam context.Context
	SegmentKey      common.SegmentKey
} {
	var calls []struct {
		ContextMoqParam context.Context
		SegmentKey      common.SegmentKey
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// IntermediateRename calls IntermediateRenameFunc.
func (mock *ManagerRefillMock) IntermediateRename() error {
	if mock.IntermediateRenameFunc == nil {
		panic("ManagerRefillMock.IntermediateRenameFunc: method is nil but ManagerRefill.IntermediateRename was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIntermediateRename.Lock()
	mock.calls.IntermediateRename = append(mock.calls.IntermediateRename, callInfo)
	mock.lockIntermediateRename.Unlock()
	return mock.IntermediateRenameFunc()
}

// IntermediateRenameCalls gets all the calls that were made to IntermediateRename.
// Check the length with:
//
//	len(mockedManagerRefill.IntermediateRenameCalls())
func (mock *ManagerRefillMock) IntermediateRenameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIntermediateRename.RLock()
	calls = mock.calls.IntermediateRename
	mock.lockIntermediateRename.RUnlock()
	return calls
}

// IsContinuable calls IsContinuableFunc.
func (mock *ManagerRefillMock) IsContinuable() bool {
	if mock.IsContinuableFunc == nil {
		panic("ManagerRefillMock.IsContinuableFunc: method is nil but ManagerRefill.IsContinuable was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsContinuable.Lock()
	mock.calls.IsContinuable = append(mock.calls.IsContinuable, callInfo)
	mock.lockIsContinuable.Unlock()
	return mock.IsContinuableFunc()
}

// IsContinuableCalls gets all the calls that were made to IsContinuable.
// Check the length with:
//
//	len(mockedManagerRefill.IsContinuableCalls())
func (mock *ManagerRefillMock) IsContinuableCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsContinuable.RLock()
	calls = mock.calls.IsContinuable
	mock.lockIsContinuable.RUnlock()
	return calls
}

// LastSegment calls LastSegmentFunc.
func (mock *ManagerRefillMock) LastSegment(v uint16, s string) uint32 {
	if mock.LastSegmentFunc == nil {
		panic("ManagerRefillMock.LastSegmentFunc: method is nil but ManagerRefill.LastSegment was just called")
	}
	callInfo := struct {
		V uint16
		S string
	}{
		V: v,
		S: s,
	}
	mock.lockLastSegment.Lock()
	mock.calls.LastSegment = append(mock.calls.LastSegment, callInfo)
	mock.lockLastSegment.Unlock()
	return mock.LastSegmentFunc(v, s)
}

// LastSegmentCalls gets all the calls that were made to LastSegment.
// Check the length with:
//
//	len(mockedManagerRefill.LastSegmentCalls())
func (mock *ManagerRefillMock) LastSegmentCalls() []struct {
	V uint16
	S string
} {
	var calls []struct {
		V uint16
		S string
	}
	mock.lockLastSegment.RLock()
	calls = mock.calls.LastSegment
	mock.lockLastSegment.RUnlock()
	return calls
}

// Reject calls RejectFunc.
func (mock *ManagerRefillMock) Reject(segmentKey common.SegmentKey, s string) {
	if mock.RejectFunc == nil {
		panic("ManagerRefillMock.RejectFunc: method is nil but ManagerRefill.Reject was just called")
	}
	callInfo := struct {
		SegmentKey common.SegmentKey
		S          string
	}{
		SegmentKey: segmentKey,
		S:          s,
	}
	mock.lockReject.Lock()
	mock.calls.Reject = append(mock.calls.Reject, callInfo)
	mock.lockReject.Unlock()
	mock.RejectFunc(segmentKey, s)
}

// RejectCalls gets all the calls that were made to Reject.
// Check the length with:
//
//	len(mockedManagerRefill.RejectCalls())
func (mock *ManagerRefillMock) RejectCalls() []struct {
	SegmentKey common.SegmentKey
	S          string
} {
	var calls []struct {
		SegmentKey common.SegmentKey
		S          string
	}
	mock.lockReject.RLock()
	calls = mock.calls.Reject
	mock.lockReject.RUnlock()
	return calls
}

// Restore calls RestoreFunc.
func (mock *ManagerRefillMock) Restore(contextMoqParam context.Context, segmentKey common.SegmentKey) (common.Snapshot, []common.Segment, error) {
	if mock.RestoreFunc == nil {
		panic("ManagerRefillMock.RestoreFunc: method is nil but ManagerRefill.Restore was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		SegmentKey      common.SegmentKey
	}{
		ContextMoqParam: contextMoqParam,
		SegmentKey:      segmentKey,
	}
	mock.lockRestore.Lock()
	mock.calls.Restore = append(mock.calls.Restore, callInfo)
	mock.lockRestore.Unlock()
	return mock.RestoreFunc(contextMoqParam, segmentKey)
}

// RestoreCalls gets all the calls that were made to Restore.
// Check the length with:
//
//	len(mockedManagerRefill.RestoreCalls())
func (mock *ManagerRefillMock) RestoreCalls() []struct {
	ContextMoqParam context.Context
	SegmentKey      common.SegmentKey
} {
	var calls []struct {
		ContextMoqParam context.Context
		SegmentKey      common.SegmentKey
	}
	mock.lockRestore.RLock()
	calls = mock.calls.Restore
	mock.lockRestore.RUnlock()
	return calls
}

// Shards calls ShardsFunc.
func (mock *ManagerRefillMock) Shards() int {
	if mock.ShardsFunc == nil {
		panic("ManagerRefillMock.ShardsFunc: method is nil but ManagerRefill.Shards was just called")
	}
	callInfo := struct {
	}{}
	mock.lockShards.Lock()
	mock.calls.Shards = append(mock.calls.Shards, callInfo)
	mock.lockShards.Unlock()
	return mock.ShardsFunc()
}

// ShardsCalls gets all the calls that were made to Shards.
// Check the length with:
//
//	len(mockedManagerRefill.ShardsCalls())
func (mock *ManagerRefillMock) ShardsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockShards.RLock()
	calls = mock.calls.Shards
	mock.lockShards.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *ManagerRefillMock) Shutdown(contextMoqParam context.Context) error {
	if mock.ShutdownFunc == nil {
		panic("ManagerRefillMock.ShutdownFunc: method is nil but ManagerRefill.Shutdown was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	mock.lockShutdown.Unlock()
	return mock.ShutdownFunc(contextMoqParam)
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//
//	len(mockedManagerRefill.ShutdownCalls())
func (mock *ManagerRefillMock) ShutdownCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockShutdown.RLock()
	calls = mock.calls.Shutdown
	mock.lockShutdown.RUnlock()
	return calls
}

// WriteAckStatus calls WriteAckStatusFunc.
func (mock *ManagerRefillMock) WriteAckStatus(contextMoqParam context.Context) error {
	if mock.WriteAckStatusFunc == nil {
		panic("ManagerRefillMock.WriteAckStatusFunc: method is nil but ManagerRefill.WriteAckStatus was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockWriteAckStatus.Lock()
	mock.calls.WriteAckStatus = append(mock.calls.WriteAckStatus, callInfo)
	mock.lockWriteAckStatus.Unlock()
	return mock.WriteAckStatusFunc(contextMoqParam)
}

// WriteAckStatusCalls gets all the calls that were made to WriteAckStatus.
// Check the length with:
//
//	len(mockedManagerRefill.WriteAckStatusCalls())
func (mock *ManagerRefillMock) WriteAckStatusCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockWriteAckStatus.RLock()
	calls = mock.calls.WriteAckStatus
	mock.lockWriteAckStatus.RUnlock()
	return calls
}

// WriteSegment calls WriteSegmentFunc.
func (mock *ManagerRefillMock) WriteSegment(contextMoqParam context.Context, segmentKey common.SegmentKey, segment common.Segment) error {
	if mock.WriteSegmentFunc == nil {
		panic("ManagerRefillMock.WriteSegmentFunc: method is nil but ManagerRefill.WriteSegment was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		SegmentKey      common.SegmentKey
		Segment         common.Segment
	}{
		ContextMoqParam: contextMoqParam,
		SegmentKey:      segmentKey,
		Segment:         segment,
	}
	mock.lockWriteSegment.Lock()
	mock.calls.WriteSegment = append(mock.calls.WriteSegment, callInfo)
	mock.lockWriteSegment.Unlock()
	return mock.WriteSegmentFunc(contextMoqParam, segmentKey, segment)
}

// WriteSegmentCalls gets all the calls that were made to WriteSegment.
// Check the length with:
//
//	len(mockedManagerRefill.WriteSegmentCalls())
func (mock *ManagerRefillMock) WriteSegmentCalls() []struct {
	ContextMoqParam context.Context
	SegmentKey      common.SegmentKey
	Segment         common.Segment
} {
	var calls []struct {
		ContextMoqParam context.Context
		SegmentKey      common.SegmentKey
		Segment         common.Segment
	}
	mock.lockWriteSegment.RLock()
	calls = mock.calls.WriteSegment
	mock.lockWriteSegment.RUnlock()
	return calls
}

// WriteSnapshot calls WriteSnapshotFunc.
func (mock *ManagerRefillMock) WriteSnapshot(contextMoqParam context.Context, segmentKey common.SegmentKey, snapshot common.Snapshot) error {
	if mock.WriteSnapshotFunc == nil {
		panic("ManagerRefillMock.WriteSnapshotFunc: method is nil but ManagerRefill.WriteSnapshot was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		SegmentKey      common.SegmentKey
		Snapshot        common.Snapshot
	}{
		ContextMoqParam: contextMoqParam,
		SegmentKey:      segmentKey,
		Snapshot:        snapshot,
	}
	mock.lockWriteSnapshot.Lock()
	mock.calls.WriteSnapshot = append(mock.calls.WriteSnapshot, callInfo)
	mock.lockWriteSnapshot.Unlock()
	return mock.WriteSnapshotFunc(contextMoqParam, segmentKey, snapshot)
}

// WriteSnapshotCalls gets all the calls that were made to WriteSnapshot.
// Check the length with:
//
//	len(mockedManagerRefill.WriteSnapshotCalls())
func (mock *ManagerRefillMock) WriteSnapshotCalls() []struct {
	ContextMoqParam context.Context
	SegmentKey      common.SegmentKey
	Snapshot        common.Snapshot
} {
	var calls []struct {
		ContextMoqParam context.Context
		SegmentKey      common.SegmentKey
		Snapshot        common.Snapshot
	}
	mock.lockWriteSnapshot.RLock()
	calls = mock.calls.WriteSnapshot
	mock.lockWriteSnapshot.RUnlock()
	return calls
}
